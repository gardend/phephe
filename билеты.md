# Базы данных
 (^^)/

## 1. Функцианальные зависисмости и нормальные формы

Термины:

**Атрибут** – свойство некоторой сущности. Часто называется полем таблицы.  
**Домен атрибута** – множество допустимых значений, которые может принимать атрибут.  
**Кортеж** – конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе описывают некоторую сущность (строка таблицы).  
**Отношение** — конечное множество кортежей (таблица).  
**Схема отношения** — конечное множество атрибутов, определяющих некоторую сущность. Иными словами, это структура таблицы, состоящей из конкретного набора полей.  
**Проекция** — отношение, полученное из заданного путём удаления и (или) перестановки некоторых атрибутов.

***Функциональная зависимость между атрибутами (множествами атрибутов) X и Y*** означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. 

Пусть задан экземпляр отношения *r(R)*. Пусть *a,b ⊆ R* - множества атрибутов. Экземпляр удовлетворяет функциональной зависимости *a → b*, если для всех пар кортежей *t1* и *t2* выполнено:  
*t1[a] = t2[a] => t1[b] = t2[b]*  
Функциональная зависимость *a → b* выполняется для схемы отношения *r(R)*, если она выполняется для каждой функциональной зависимости.

***Аномалия*** - это такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенноу сложняет обработку БД. (Причина - излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей в таблице)

***Нормальная форма*** - требование, продъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц)

***Первая нормальная форма***:  
Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

***Вторая нормальная форма***:  
Отношение находится в 2НФ, если оно находится в 1НФ, и каждый не ключевой атрибут неприводимо зависит от Первичного ключа. (неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость)

***Третья нормальная форма***:  
Отношение находится в 3НФ, если оно находится в 2НФ, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

Еще существуют:

***Нормальная форма Бойеса-Кодда (НФБК)***:  
Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.

***Четвертая нормальная форма***:  
Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
 
***Пятая нормальная форма***:  
Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами.

***Доменно-ключевая нормальная форма***:  
Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.

***Шестая нормальная форма***:  
Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения.   
Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 


## 2. Семантическая модель Entity-Relationship, E/R-диаграммы

Основными понятиями ER-модели являются *сущность, связь и атрибут*.   

***Сущность*** – это реальный или представляемый объект, информация о котором должна сохраняться и быть доступной. При этом имя сущности – это имя типа, а не некоторого конкретного экземпляра этого типа. 

***Атрибут сущности*** – это любая деталь, которая служит для уточнения, идентификации, классификации, числовой характеристики или выражения состояния сущности.

***Связь*** – это графически изображаемая ассоциация, устанавливаемая между двумя типами сущностей.  
В любой связи выделяются два конца (в соответствии с существующей парой связываемых сущностей), на каждом из которых указываются:  
 -имя конца связи  
 -степень конца связи  
 -обязательность связи

При определении типа сущности необходимо гарантировать, что каждый экземпляр сущности отличим от любого другого экземпляра той же сущности.   
Уникальным идентификатором может быть:  
 -атрибут (или комбинация атрибутов)  
 -связь (или комбинация связей)  
 -комбинация атрибутов и связей

## 3. Проектирование реляционных схем с использованием ER-диаграмм.

### Получение таблицы из простого типа сущности
Простым типом сущности называется тип сущности, не являющийся подтипом и не имеющий подтипов. 

Каждый простой тип сущности превращается в **таблицу**:
+ Имя сущности становится именем таблицы.
+ Каждый атрибут становится столбцом таблицы; может выбираться более точный формат представления данных.
+ Экземпляр типа сущности становится строкой таблицы.
+ Уникальный идентификатор сущности становятся первичным ключом таблицы.

**Преобразование связей:**
+ Связи «многие к одному» (и «один к одному») становятся внешними ключами, т.е. образуется копия уникального идентификатора сущности на конце связи «один», и соответствующие столбцы составляют внешний ключ таблицы, соответствующей типу сущности на конце связи «многие».
+ Если между двумя типами сущности A и B имеется связь «один к одному», то соответствующий внешний ключ по желанию проектировщика может быть объявлен как в таблице A, так и в таблице B.
+ Чтобы отразить в определении таблицы ограничение, которое заключается в том, что степень конца связи равна единице, соответствующий (возможно, составной) столбец должен быть дополнительно специфицирован как возможный ключ таблицы.
+ Для поддержки связи «многие ко многим» между типами сущности A и B создается дополнительная таблица AB с двумя столбцами, один из которых содержит уникальные идентификаторы экземпляров сущности A, а другой – уникальные идентификаторы экземпляров сущности B.
+ Обозначим через УИД(c) уникальный идентификатор экземпляра некоторого типа сущности C. Тогда, если в экземпляре связи «многие ко многим» участвуют экземпляры $a_1,a_2,...,a_n$ типа сущности A и экземпляры $b_1,b_2,...,b_m$ типа сущности B, то в таблице AB должны присутствовать все строки вида <УИД($a_i$), УИД($b_j$)>, где i = 1,2,...,n; j = 1,2,...,m.


### Получение таблицы из сложного типа сущности
Существует два способа представить наследование сущностей в реляционной схеме. 

#### Первый способ 
Он заключается в создании единой таблицы для всех подтипов. Эта таблица содержит столбцы, соответствующие каждому атрибуту (и связям) каждого подтипа, а также один специальный столбец «код подтипа». Для каждой строки таблицы значение этого столбца определяет конкретный подтип, которому соответствует строка.

>Достоинства:
>>обеспечение простого доступа к экземплярам супертипа и не слишком сложный доступ к экземплярам подтипов
>>возможность обойтись небольшим числом таблиц

>Недостатки
>>приложения, работающие с одной таблицей супертипа, должны содержать дополнительный программный код для работы с разными наборами столбцов и разными ограничениями целостности
>>общая для всех подтипов таблица потенциально может стать узким местом при многопользовательском доступе по причине возможности блокировки таблицы целиком
>>потенциально в общей таблице будет содержаться много неопределенных значений, что может привести к непроизводительному расходу внешней памяти


#### Второй способ 
Он предполагает создание отдельной таблицы для каждого подтипа. В этом случае для получения всех кортежей супертипа нужно объединить проекции таблиц подтипов, на заголовок таблицы супертипа. Другими словами, из всех таблиц подтипов выбираются общие столбцы супертипа. 

>Достоинства:
>>действуют более понятные правила работы с подтипами (каждому подтипу соответствует отдельная таблица)
>>упрощается логика приложений; каждая программа работает только с нужной таблицей

>Недостатки
>>в общем случае требуется слишком много отдельных таблиц
>>работа с экземплярами супертипа на основе представления, объединяющего таблицы супертипов, может оказаться недостаточно эффективной
>>поскольку множество экземпляров супертипа является объединением множеств экземпляров подтипов, не все РСУБД могут обеспечить выполнение операций модификации экземпляров супертипа


### Взаимно-исключающие связи
Существуют два способа формирования схемы реляционной БД при наличии взаимно-исключающих связей (имеются в виду связи «один ко многим», причем конец связи «многие» находится на стороне сущности, для которой связи являются взаимно-исключающими):
+ определение таблицы с одним столбцом для представления всех взаимноисключающих связей, т.е. общее хранение внешних ключей
  + Преимущество этого подхода состоит в том, что в таблице, соответствующей сущности с взаимно-исключающими связями, появляется всего два дополнительных столбца. Недостатком является усложнение выполнения операции соединения.
+ определение таблицы, в которой каждой взаимно-исключающей связи соответствует отдельный столбец, т.е. раздельное хранение внешних ключей
  + При использовании этогоого подхода соединения являются явными (и естественными). Недостаток состоит в том, что требуется иметь столько столбцов, сколько имеется альтернативных связей. Кроме того, в каждом из таких столбцов будет содержаться много неопределенных значений, хранение которых может привести к излишнему расходу внешней памяти.



## 4. Диаграммы классов языка UML

***UML (Unified Modeling Language)*** является языком объектно-ориентированного моделирования.   
Про сам язык — язык графического описания для объектного моделирования в области разработки программного обеспечения, моделирования бизнес-процессов, системного проектирования и отображения организационных структур.

Язык UML состоит из нескольких подъязыков (они все графические, диаграммные), в число которых входит подъязык диаграмм классов. Эти подъязыки (спецификации) называются **метамоделями**. В терминах UML концептуальная схема называется **моделью**. Модель может быть представлена из метамоделей.  
UML позволяет моделировать разные виды систем: чисто программные, чисто аппаратные, программно-аппаратные, смешанные (включающие деятельность людей) и т.д.

***Диаграмма классов (в терминологии UML)*** - это диаграмма, на которой показан набор классов (и некоторых других сущностей, не имеющих явного отношения к проектированию БД), а также связей между этими классами. Диаграмма классов может включать комментарии и ограничения.  

Как и в модели ER-диаграмм, в UML для родового обозначения связей используется термин «связь».
Для диаграмм классов UML могут задаваться ограничения на естественном языке или же на языке объектных ограничений OCL (Object Constraints Language).

***Класс*** - это именованное описание совокупности объектов с общими атрибутами, операциями, связями и семантикой. 

***Атрибут класса*** - это именованное свойство класса, описывающее множество значений, которые могут принимать экземпляры этого свойства. Множество всех атрибутов класса описывает структуру этого класса. 

Класс может иметь любое число атрибутов (в том числе ноль). Свойство, выражаемое атрибутом, является свойством моделируемой сущности, общим для всех объектов данного класса, т.е. атрибут является абстракцией состояния объекта.

***Операция класса*** - это именованная услуга, которую можно запросить у любого объекта этого класса. ***Операция*** – это то, что можно делать с объектом. Класс может содержать любое число операций (в частности, ни одной). Набор операций класса является общим для всех объектов данного класса.

В диаграмме классов могут участвовать связи трёх категорий:
  -зависимость (dependency)
  -обобщение (generalization)
  -ассоциация (association)
  
***Зависимость*** - это связь, показывающая, что изменение описании одного класса может повлиять на поведение другого класса, использующего первый класс. Как правило зависимость отражает тот факт, что в сигнатуре операции одного класса параметром является объект другого класса. 

***Обобщение*** - это связь между суперклассом (родителем) и подклассом (потомком). Обобщения иногда называют связями «is a», имея в виду, что класс-потомок является частным случаем класса-предка. 

***Ассоциация*** - это структурная связь, показывающая, что объекты одного класса некоторым образом связаны с объектами другого или того же самого класса. В ассоциации могут связываться два класса, и тогда она называется бинарной. Но допускается  также создание ассоциаций, связывающих сразу n классов (они называются n-арными ассоциациями).

## 5. Обработка запросов. Преобразование SQL-выражение во внутреннее представление СУБД

Основные шаги обработки запросов:
  1. Парсинг и трансляция
  2. Оптимизация
  3. Вычисление

**Парсинг**:
  -Осуществляется трансляция запроса в его внутреннюю форму. Затем осуществляется трансляция в реляционную алгебру.
  -Парсер осуществляет проверку синтаксиса и проверку отношений
  
**Вычисление**:
  -Механизм выполнения запросов принимает на вход план запросов, выполняет данный план, и возвращает ответ для запроса.

**Оптимизация**:
  -Из всех эквивалентных планов выполнения выбирается с меньшей стоимостью. Стоимость вычисляется с использованием статистической информации из каталога базы данных. 


## 6. Меры стоимости запросов. Вычисление стоимости операций

Многие факторы участвуют при оценке времени: Доступ к диску, CPU, и сетевые коммуникации
  
Стоимость может быть вычислена на основе
<ul>
<li>времени ответа, т.е. общее время ответа на запросы</li>
<li>общее потребление ресурсов</li>
</ul>
  
Будем рассматривать метрику по потреблению ресурсов
<ul>
<li>Время ответа сложнее вычислить, уменьшение потребления ресурсов – хорошая метрика в общей (shared) БД</li>
</ul>
  
  
Мы игнорируем стоимость CPU для простоты
<ul>
<li>Реальные системы используют стоимость CPU для оценки</li>
<li>Стоимость сети рассматривается для параллельных систем</li>
</ul>
  
### Опишем, как вычислить стоимость для каждой операции (Стоимость записи на диск игнорируем для простоты):
#### 1. Стоимость доступа на диск может быть рассчитана как:
   <ul>
  <li>Число поисков * среднее время поиска</li>
  <li>Число блоков чтения * среднее время чтения блока </li>
  <li>Число блоков записи * среднее время записи блока</li>
  </ul>


  Для простоты учитываем **число трансфера блока с диска и число поисков** как меры стоимости
   <ul>
  <li>t<sub>T</sub> - время трансфера для одного блока (предполагаем, что стоимость записи соответствует стоимости чтения)</li>
  <li>t<sub>S</sub> - время для одного поиска</li>
  </ul>


  3. t<sub>T</sub> и t<sub>S</sub> зависят от того, где хранятся данные. с 4 КВ блоками:
   <ul>
  <li>HDD: t<sub>S</sub> = 4 msec и t<sub>T</sub> = 0.1 msec</li>
  <li>SSD: t<sub>S</sub> = 20-90 microsec и t<sub>T</sub> = 2-10 microsec для 4 КВ</li>
  </ul>


**Стоимость для b трансферов блоков и S поисков:**
$$b * t_T + S * t_S$$


#### 2. Стоимость операций выборки
  1. Алгоритм А1 (**Линейный поиск**)    
     Обходит каждый блок файла и тестирует все записи на условие отбора.
     
     + Стоимость выполнения = $b_r$ трансферов блока + 1 поиск ($b_r$  определяет число блоков записей в отношении r)
     + Стоимость = ($b_r$ / 2) трансферов блока + 1 поиск

     >Линейный поиск может применяться независимо от 
     >+ Условия выборки
     >+ Сортировки записей в файле
     >+ Доступности индексов

 
 2. А2 (**кластерный индекс, равенство по ключу**)     
    Вывод: одна запись, которая подходит по равенству по ключу.
    Стоимость: $$(h_i + 1) * (t_T + t_S)$$
    $h_i$ - высота дерева

   
3. A3 (**кластерный индекс, равенство не по ключу**).    
   Вывод: несколько записей.
   > Записи должны быть на последовательных блоках

   Стоимость: $$h_i * (t_T + t_S) + t_T + t_S * b$$
   b - число блоков, содержащих совпадающие записи


4. A4 (**вторичный индекс, равенство (не) по ключу**).    
   Возвращает одну запись, если ключ поиска _уникален_.
   Стоимость: $$(h_i + 1) * (t_T + t_S)$$

   Возвращает несколько записей, если ключ поиска м.б. _не уникален_.
   Стоимость: $$(h_i + n) * (t_T + t_S)$$
   n - количество совпадающих записей (могут быть в разных блоках)


5. A5 (**кластерный индекс, сравнение**). (Отношение отсортировано по A)
   + Для $\sigma{(A >= V)}(r)$  используется индекс для нахождения первого кортежа  v  и далее последовательный обход отношения.
   + Для $\sigma{(A <= V)}(r)$ просто последовательный обход отношения до момента, как кортеж > v.


6. A6 (**кластерный индекс, сравнение**).
   + Для $\sigma{(A >= V)}(r)$  используется индекс для нахождения первой записи  v  и осуществлять последовательный поиск для нахождения указателя на записи.
   + Для $\sigma{(A <= V)}(r)$ обходить корневые страницы до условия > v
   + Если условие не соответствует порядку А, то может потребоваться одно чтение на запись



## 7.	Меры стоимости запросов. Оценка операций соединения.
> Черновой вариант первого вопроса из седьмого билета. Доработаю, когда разберусь в нем.

Многие факторы, участвующие при оценке времени запроса: доступ к диску, CPU, и сетевые коммуникации
  
Стоимость может быть вычислена на основе
<ul>
<li>времени ответа, т.е. общее время ответа на запросы</li>
<li>общее потребление ресурсов</li>
</ul>

#### Базовый алгоритм для соединения 𝑟⋈_𝜃 𝑠:

<code>
for каждого кортежа 𝑡_𝑟 в r:
    for каждого кортежа 𝑡_𝑠 в s:
       сравнить пару (𝑡_𝑟, 𝑡_𝑠) на 𝜃
            если true, то добавить 𝑡_𝑟⋅𝑡_𝑠 в результат
</code>
R – внешнее отношение
S – внутреннее отношение

 
Так как типы соединия бывают разными, то проведем оценку запроса для каждого из них. 
+ #### Merge join
  Каждый блок прочитан будет только однажды при условии, что все кортежи помещаются в памяти.
  
  Стоимость переноса: $b_r + b_s$
  Стоимость поиска: $b_r/b_b + b_S/b_b$

  **Реализация соединения слиянием:**
  
  <code>
  pr := адрес первого кортежа r
  ps := адрес первого кортежа s
  while (ps != null and pr != null)
  $𝑡_𝑠$≔кортеж указателя 𝑝𝑠
  $S_𝑠$  ≔{$𝑡_𝑠$ }
  ps ≔следующий кортеж а 𝑠
  𝑑𝑜𝑛𝑒 ≔𝑓𝑎𝑙𝑠𝑒
  wh𝑖𝑙𝑒 (𝑛𝑜𝑡 𝑑𝑜𝑛𝑒 𝑎𝑛𝑑 𝑝𝑠 !=𝑛𝑢𝑙𝑙)
    $t_𝑠′$≔кортеж указателя 𝑝𝑠
    if ($t_s′$ [JoinAttrs]=$t_𝑠$ [𝐽𝑜𝑖𝑛𝐴𝑡𝑡𝑟𝑠]
      $S_𝑠$  ≔$𝑆_𝑆$∪{$𝑡_𝑠′$}
      ps ≔следующий кортеж в 𝑠
    else
       𝑑𝑜𝑛𝑒 ≔𝑡𝑟𝑢𝑒
   $t_𝑟$≔кортеж указателя 𝑝𝑟
  wh𝑖𝑙𝑒 (𝑝𝑟 !=𝑛𝑢𝑙𝑙 𝑎𝑛𝑑 $𝑡_𝑟$ [𝐽𝑜𝑖𝑛𝐴𝑡𝑡𝑟 ]<$𝑡_𝑠$ [𝐽𝑜𝑖𝑛𝐴𝑡𝑡𝑟𝑠])
    pr ≔следующий кортеж в r
    $t_r$  ≔кортеж указателя pr
  wh𝑖𝑙𝑒 (𝑝𝑟 !=𝑛𝑢𝑙𝑙 𝑎𝑛𝑑 $𝑡_𝑟$ [𝐽𝑜𝑖𝑛𝐴𝑡𝑡𝑟 ]=$𝑡_𝑠$ [𝐽𝑜𝑖𝑛𝐴𝑡𝑡𝑟𝑠])
    pr ≔следующий кортеж в r
    𝑓𝑜𝑟 𝑒𝑎𝑐ℎ $𝑡_𝑠$  в $𝑆_𝑠$
      Добавить $𝑡_𝑠$ 〖⋈𝑡_𝑠  в результат.   〗_
    pr ≔следующий кортеж в r
    $t_r$  ≔кортеж указателя pr
  </code>

+ #### Hash join
Алгоритм выглядит следующим образом:
  + Разбить отношение s на секции
  + Разбить отношение r на секции
  + Для каждого i:
    + Загрузить $s_i$ в память и построить хеш-индекс в памяти
    + Считывать кортежи в $r_i$ по одному. Для каждого кортежа $t_r$ найти совпадающий кортеж $t_s$ в s. Вывести конкатенацию.
  В случае, если число секций больше числа блоков в памяти, то появляется рекурсивное партиционирование.


> Стоимость переноса: $3(b_r + b_s)$

> Стоимость поиска: $2(b_r/b_b + b_S/b_b)$



## 8. Изолированность транзакций.
В современных СУБД поддерживается понятие транзакции, характеризуемое аббревиатурой ACID:
+ Atomicity (атомарность)
+ Consistency (целостность)
+ Isolation (изолированность)
+ Durability (долговечность)

>**Изолированность:**
>>Требуется, чтобы две одновременно выполняемые транзакции никаким образом не действовали одна на другую. 
>>Результаты выполнения операций транзакции $T_1$ не должны быть видны никакой другой транзакции $T_2$ до тех пор, пока транзакция $T_1$ не завершится успешным образом.

В многопользовательских системах с одной базой данных одновременно может работать несколько пользователей или прикладных программ. Предельной задачей системы является обеспечение изолированности пользователей (приложений), т.е. создание достоверной и надежной иллюзии того, что каждый из пользователей работает с базой данных в одиночку. 
В связи со свойством сохранения целостности базы данных транзакции являются подходящими единицами изолированности пользователей. 




